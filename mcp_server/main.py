# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:24:07+00:00



import argparse
import json
import os
from pathlib import Path
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Path, Query, UploadFile
from pydantic import constr
from starlette.requests import Request

from models import (
    AccessCredential,
    Account,
    AccountCreationRequest,
    AccountList,
    AccountsAccountnameUsersGetResponse,
    AccountStatus,
    AddAnalysisArchiveResult,
    AnalysisArchiveRules,
    AnalysisArchiveTransitionRule,
    AnalysisStatus1,
    AnchoreImageList,
    AnchoreImageTagSummaryList,
    ApiErrorResponse,
    ArchivedAnalyses,
    ArchivedAnalysis,
    ArchiveSummary,
    ContentFilesResponse,
    ContentJAVAPackageResponse,
    ContentMalwareResponse,
    ContentPackageResponse,
    CredentialList,
    CredentialType,
    DeleteImageResponse,
    DeleteImageResponseList,
    EventResponse,
    EventsDeleteResponse,
    EventsList,
    EventTypesList,
    FeedMetadata,
    FeedSyncResults,
    FileContentSearchList,
    Id,
    ImageAnalysisReferences,
    ImageAnalysisRequest,
    ImageDigests,
    ImageImportContentResponse,
    ImageImportOperation,
    ImageImports,
    ImagePackageManifest,
    ImagesByIdImageIdContentGetResponse,
    ImagesByIdImageIdVulnGetResponse,
    ImagesImageDigestContentGetResponse,
    ImagesImageDigestMetadataGetResponse,
    ImagesImageDigestVulnGetResponse,
    ImageStatus1,
    ImageStatus3,
    ImportContentDigestList,
    ImportsImagesOperationIdImageConfigPostRequest,
    ImportsImagesOperationIdManifestPostRequest,
    ImportsImagesOperationIdParentManifestPostRequest,
    MetadataResponse,
    Namespace,
    NotificationType,
    PaginatedImageList,
    PaginatedVulnerabilityList,
    PaginatedVulnerableImageList,
    PolicyBundle,
    PolicyBundleList,
    PolicyBundleRecord,
    PolicyEvaluationList,
    RegistryConfigurationList,
    RegistryConfigurationRequest,
    RetrievedFileList,
    SecretSearchList,
    ServiceList,
    ServiceVersion,
    Severity,
    State5,
    StatusResponse,
    SubscriptionList,
    SubscriptionRequest,
    SubscriptionUpdate,
    SystemErrorCodesGetResponse,
    SystemFeedsFeedGroupPutResponse,
    SystemFeedsGetResponse,
    SystemPolicySpecGetResponse,
    SystemStatusResponse,
    TokenResponse,
    User,
    UserCreationRequest,
    VulnerabilityResponse,
)

app = MCPProxy(
    contact={'email': 'nurmi@anchore.com', 'x-twitter': 'anchore'},
    description='This is the Anchore Engine API. Provides the primary external API for users of the service.',
    license={
        'name': 'Apache 2.0',
        'url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
    },
    title='Anchore Engine API Server',
    version='0.1.20',
    servers=[{'url': '/'}, {'url': 'http://anchore.local'}],
)


@app.get(
    '/#-datamodel-code-generator-#-root-#-special-#',
    description=""" Simple status check """,
    tags=[
        'user_information_management',
        'credential_operations',
        'system_event_management',
        'archive_operations',
        'system_health_checks',
        'image_analysis_management',
        'image_metadata_retrieval',
        'image_security_policy_evaluation',
        'import_operations_management',
        'docker_image_import',
        'policy_configuration_management',
        'vulnerability_data_querying',
        'registry_configuration_management',
        'repository_subscription_operations',
        'service_current_status_check',
        'subscription_operations_management',
        'feed_management_operations',
        'service_configuration_management',
        'error_information_handling',
        'webhook_functionality_testing',
    ],
)
def ping():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/account', tags=['user_information_management'])
def get_users_account():
    """
    List the account for the authenticated user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/accounts', tags=['user_information_management'])
def list_accounts(state: Optional[State5] = None):
    """
    List user summaries. Only available to the system admin user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/accounts', tags=['user_information_management', 'credential_operations'])
def create_account(body: AccountCreationRequest):
    """
    Create a new user. Only avaialble to admin user.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/accounts/{accountname}',
    tags=['user_information_management', 'credential_operations'],
)
def delete_account(accountname: str):
    """
    Delete the specified account, only allowed if the account is in the disabled state. All users will be deleted along with the account and all resources will be garbage collected
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/accounts/{accountname}', tags=['user_information_management'])
def get_account(accountname: str):
    """
    Get info about an user. Only available to admin user. Uses the main user Id, not a username.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/accounts/{accountname}/state',
    tags=['user_information_management', 'credential_operations'],
)
def update_account_state(accountname: str, body: AccountStatus = ...):
    """
    Update the state of an account to either enabled or disabled. For deletion use the DELETE route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{accountname}/users',
    tags=['user_information_management', 'credential_operations'],
)
def list_users(accountname: str):
    """
    List accounts for the user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts/{accountname}/users',
    tags=['user_information_management', 'credential_operations'],
)
def create_user(accountname: str, body: UserCreationRequest = ...):
    """
    Create a new user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/accounts/{accountname}/users/{username}',
    tags=['user_information_management', 'credential_operations'],
)
def delete_user(accountname: str, username: str = ...):
    """
    Delete a specific user credential by username of the credential. Cannot be the credential used to authenticate the request.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{accountname}/users/{username}',
    tags=['user_information_management', 'credential_operations'],
)
def get_account_user(accountname: str, username: str = ...):
    """
    Get a specific user in the specified account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/accounts/{accountname}/users/{username}/credentials',
    tags=['user_information_management', 'credential_operations'],
)
def delete_user_credential(
    accountname: str, username: str = ..., credential_type: CredentialType = ...
):
    """
    Delete a credential by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{accountname}/users/{username}/credentials',
    tags=['user_information_management', 'credential_operations'],
)
def list_user_credentials(accountname: str, username: str = ...):
    """
    Get current credential summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts/{accountname}/users/{username}/credentials',
    tags=['user_information_management', 'credential_operations'],
)
def create_user_credential(
    accountname: str, username: str = ..., body: AccessCredential = ...
):
    """
    add/replace credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/archives', tags=['error_information_handling'])
def list_archives():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archives/images', tags=['user_information_management', 'credential_operations']
)
def list_analysis_archive():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/archives/images', tags=['image_analysis_management', 'image_metadata_retrieval']
)
def archive_image_analysis(body: ImageAnalysisReferences):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/archives/images/{imageDigest}',
    description=""" Performs a synchronous archive deletion """,
    tags=[
        'image_analysis_management',
        'image_metadata_retrieval',
        'vulnerability_data_querying',
    ],
)
def delete_archived_analysis(
    image_digest: str = Path(..., alias='imageDigest'), force: Optional[bool] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archives/images/{imageDigest}',
    description=""" Returns the archive metadata record identifying the image and tags for the analysis in the archive. """,
    tags=[
        'image_analysis_management',
        'image_metadata_retrieval',
        'image_security_policy_evaluation',
    ],
)
def get_archived_analysis(image_digest: str = Path(..., alias='imageDigest')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archives/rules', tags=['system_health_checks', 'service_current_status_check']
)
def list_analysis_archive_rules(system_global: Optional[bool] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/archives/rules', tags=['archive_operations'])
def create_analysis_archive_rule(body: AnalysisArchiveTransitionRule):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/archives/rules/{ruleId}', tags=['archive_operations'])
def delete_analysis_archive_rule(rule_id: str = Path(..., alias='ruleId')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/archives/rules/{ruleId}', tags=['archive_operations'])
def get_analysis_archive_rule(rule_id: str = Path(..., alias='ruleId')):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event_types',
    description=""" Returns list of event types in the category hierarchy """,
    tags=['system_event_management'],
)
def list_event_types():
    """
    List Event Types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/events',
    description=""" Delete all or a subset of events filtered using the optional query parameters """,
    tags=['system_event_management'],
)
def delete_events(
    before: Optional[str] = None,
    since: Optional[str] = None,
    level: Optional[str] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events',
    description=""" Returns a paginated list of events in the descending order of their occurrence. Optional query parameters may be used for filtering results """,
    tags=['system_event_management'],
)
def list_events(
    source_servicename: Optional[str] = None,
    source_hostid: Optional[str] = None,
    event_type: Optional[constr(pattern=r'^[a-z0-9-_.*]+$')] = None,
    resource_type: Optional[str] = None,
    resource_id: Optional[str] = None,
    level: Optional[str] = None,
    since: Optional[str] = None,
    before: Optional[str] = None,
    page: Optional[int] = 1,
    limit: Optional[int] = 100,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/events/{eventId}',
    description=""" Delete an event by its event ID """,
    tags=['system_event_management'],
)
def delete_event(
    event_id: str = Path(..., alias='eventId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete Event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events/{eventId}',
    description=""" Lookup an event by its event ID """,
    tags=['system_event_management'],
)
def get_event(
    event_id: str = Path(..., alias='eventId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get Event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health',
    description=""" Health check, returns 200 and no body if service is running """,
    tags=['error_information_handling'],
)
def health_check():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/images',
    description=""" Delete analysis for image digests in the list asynchronously """,
    tags=['image_analysis_management', 'archive_operations'],
)
def delete_images_async(
    image_digests: ImageDigests = Query(..., alias='imageDigests'),
    force: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Bulk mark images for deletion
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images',
    description=""" List all images visible to the user """,
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_images(
    history: Optional[bool] = None,
    fulltag: Optional[str] = None,
    image_status: Optional[ImageStatus1] = 'active',
    analysis_status: Optional[AnalysisStatus1] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List all visible images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images',
    description=""" Creates a new analysis task that is executed asynchronously """,
    tags=['image_analysis_management'],
)
def add_image(
    force: Optional[bool] = None,
    autosubscribe: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: ImageAnalysisRequest = ...,
):
    """
    Submit a new image for analysis by the engine
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/images/by_id/{imageId}', tags=['image_analysis_management'])
def delete_image_by_image_id(
    image_id: str = Path(..., alias='imageId'),
    force: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete image by docker imageId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def get_image_by_image_id(
    image_id: str = Path(..., alias='imageId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Lookup image by docker imageId
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/check',
    description=""" Get the policy evaluation for the given image """,
    tags=['image_security_policy_evaluation', 'image_analysis_management'],
)
def get_image_policy_check_by_image_id(
    image_id: str = Path(..., alias='imageId'),
    policy_id: Optional[str] = Query(None, alias='policyId'),
    tag: str = ...,
    detail: Optional[bool] = None,
    history: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Check policy evaluation status for image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/content',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_image_content_by_imageid(
    image_id: str = Path(..., alias='imageId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List image content types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/content/files',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type_image_id_files(
    image_id: str = Path(..., alias='imageId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/content/java',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type_image_id_javapackage(
    image_id: str = Path(..., alias='imageId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type java
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/content/{ctype}',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type_image_id(
    image_id: str = Path(..., alias='imageId'),
    ctype: str = ...,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/vuln',
    tags=['vulnerability_data_querying', 'image_security_policy_evaluation'],
)
def get_image_vulnerability_types_by_image_id(
    image_id: str = Path(..., alias='imageId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get vulnerability types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/by_id/{imageId}/vuln/{vtype}',
    tags=['vulnerability_data_querying', 'image_analysis_management'],
)
def get_image_vulnerabilities_by_type_image_id(
    image_id: str = Path(..., alias='imageId'),
    vtype: str = ...,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get vulnerabilities by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/images/{imageDigest}', tags=['image_analysis_management', 'archive_operations']
)
def delete_image(
    image_digest: str = Path(..., alias='imageDigest'),
    force: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete an image analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get image metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/artifacts/file_content_search',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_file_content_search_results(
    image_digest: str = Path(..., alias='imageDigest')
):
    """
    Return a list of analyzer artifacts of the specified type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/artifacts/retrieved_files',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_retrieved_files(image_digest: str = Path(..., alias='imageDigest')):
    """
    Return a list of analyzer artifacts of the specified type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/artifacts/secret_search',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_secret_search_results(image_digest: str = Path(..., alias='imageDigest')):
    """
    Return a list of analyzer artifacts of the specified type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/check',
    description=""" Get the policy evaluation for the given image """,
    tags=['image_security_policy_evaluation', 'image_analysis_management'],
)
def get_image_policy_check(
    image_digest: str = Path(..., alias='imageDigest'),
    policy_id: Optional[str] = Query(None, alias='policyId'),
    tag: str = ...,
    detail: Optional[bool] = None,
    history: Optional[bool] = None,
    interactive: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Check policy evaluation status for image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/content',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def list_image_content(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List image content types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/content/files',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type_files(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/content/java',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type_javapackage(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type java
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/content/malware',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def get_image_content_by_type_malware(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type malware
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/content/{ctype}',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_content_by_type(
    image_digest: str = Path(..., alias='imageDigest'),
    ctype: str = ...,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the content of an image by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/metadata',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def list_image_metadata(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List image metadata types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/metadata/{mtype}',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_metadata_by_type(
    image_digest: str = Path(..., alias='imageDigest'),
    mtype: str = ...,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get the metadata of an image by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/sboms/native',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def get_image_sbom_native(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get image sbom in the native Anchore format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/vuln',
    tags=['image_analysis_management', 'vulnerability_data_querying'],
)
def get_image_vulnerability_types(
    image_digest: str = Path(..., alias='imageDigest'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get vulnerability types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageDigest}/vuln/{vtype}',
    tags=['image_analysis_management', 'vulnerability_data_querying'],
)
def get_image_vulnerabilities_by_type(
    image_digest: str = Path(..., alias='imageDigest'),
    vtype: str = ...,
    force_refresh: Optional[bool] = None,
    vendor_only: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get vulnerabilities by type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/import/images',
    tags=['import_operations_management', 'docker_image_import', 'archive_operations'],
)
def import_image_archive(file: UploadFile):
    """
    Import an anchore image tar.gz archive file. This is a deprecated API replaced by the "/imports/images" route
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/imports/images', tags=['import_operations_management'])
def list_operations():
    """
    Lists in-progress imports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images',
    tags=['image_analysis_management', 'import_operations_management'],
)
def create_operation():
    """
    Begin the import of an image analyzed by Syft into the system
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/imports/images/{operation_id}', tags=['credential_operations'])
def invalidate_operation(operation_id: str):
    """
    Invalidate operation ID so it can be garbage collected
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/imports/images/{operation_id}', tags=['import_operations_management'])
def get_operation(operation_id: str):
    """
    Get detail on a single import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/imports/images/{operation_id}/dockerfile',
    tags=['docker_image_import', 'import_operations_management'],
)
def list_import_dockerfiles(operation_id: str):
    """
    List uploaded dockerfiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images/{operation_id}/dockerfile',
    tags=['import_operations_management', 'image_analysis_management'],
)
def import_image_dockerfile(operation_id: str):
    """
    Begin the import of an image analyzed by Syft into the system
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/imports/images/{operation_id}/image_config',
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_import_image_configs(operation_id: str):
    """
    List uploaded image configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images/{operation_id}/image_config',
    tags=['docker_image_import', 'import_operations_management'],
)
def import_image_config(
    operation_id: str, body: ImportsImagesOperationIdImageConfigPostRequest = ...
):
    """
    Import a docker or OCI image config to associate with the image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/imports/images/{operation_id}/manifest',
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def list_import_image_manifests(operation_id: str):
    """
    List uploaded image manifests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images/{operation_id}/manifest',
    tags=['import_operations_management', 'docker_image_import'],
)
def import_image_manifest(
    operation_id: str, body: ImportsImagesOperationIdManifestPostRequest = ...
):
    """
    Import a docker or OCI distribution manifest to associate with the image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/imports/images/{operation_id}/packages',
    tags=['import_operations_management', 'docker_image_import'],
)
def list_import_packages(operation_id: str):
    """
    List uploaded package manifests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images/{operation_id}/packages',
    tags=['image_analysis_management', 'import_operations_management'],
)
def import_image_packages(operation_id: str, body: ImagePackageManifest = ...):
    """
    Begin the import of an image analyzed by Syft into the system
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/imports/images/{operation_id}/parent_manifest', tags=['docker_image_import'])
def list_import_parent_manifests(operation_id: str):
    """
    List uploaded parent manifests (manifest lists for a tag)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/imports/images/{operation_id}/parent_manifest',
    tags=['import_operations_management', 'docker_image_import'],
)
def import_image_parent_manifest(
    operation_id: str, body: ImportsImagesOperationIdParentManifestPostRequest = ...
):
    """
    Import a docker or OCI distribution manifest list to associate with the image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/oauth/token',
    description=""" Request a jwt token for subsequent operations, this request is authenticated with normal HTTP auth """,
    tags=[
        'user_information_management',
        'credential_operations',
        'system_event_management',
        'system_health_checks',
        'error_information_handling',
    ],
)
def get_oauth_token(request: Request):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/policies',
    description=""" List all saved policy bundles """,
    tags=['policy_configuration_management', 'image_security_policy_evaluation'],
)
def list_policies(
    detail: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List policies
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/policies',
    description=""" Adds a new policy bundle to the system """,
    tags=['policy_configuration_management'],
)
def add_policy(
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: PolicyBundle = ...,
):
    """
    Add a new policy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/policies/{policyId}',
    description=""" Delete the specified policy """,
    tags=['policy_configuration_management', 'credential_operations'],
)
def delete_policy(
    policy_id: str = Path(..., alias='policyId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete policy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/policies/{policyId}',
    description=""" Get the policy bundle content """,
    tags=['policy_configuration_management', 'image_security_policy_evaluation'],
)
def get_policy(
    policy_id: str = Path(..., alias='policyId'),
    detail: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get specific policy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/policies/{policyId}',
    description=""" Update/replace and existing policy """,
    tags=['policy_configuration_management'],
)
def update_policy(
    policy_id: str = Path(..., alias='policyId'),
    active: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: PolicyBundleRecord = ...,
):
    """
    Update policy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/query/images/by_package',
    description=""" Filterable query interface to search for images containing specified package """,
    tags=['image_metadata_retrieval', 'image_analysis_management'],
)
def query_images_by_package(
    name: str,
    package_type: Optional[str] = None,
    version: Optional[str] = None,
    page: Optional[str] = None,
    limit: Optional[int] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List of images containing given package
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/query/images/by_vulnerability',
    description=""" Returns a listing of images and their respective packages vulnerable to the given vulnerability ID """,
    tags=['vulnerability_data_querying', 'image_security_policy_evaluation'],
)
def query_images_by_vulnerability(
    vulnerability_id: str,
    namespace: Optional[str] = None,
    affected_package: Optional[str] = None,
    severity: Optional[Severity] = None,
    vendor_only: Optional[bool] = True,
    page: Optional[int] = None,
    limit: Optional[int] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List images vulnerable to the specific vulnerability ID.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/query/vulnerabilities',
    description=""" List (w/filters) vulnerability records known by the system, with affected packages information if present """,
    tags=['vulnerability_data_querying'],
)
def query_vulnerabilities(
    id: Id,
    affected_package: Optional[str] = None,
    affected_package_version: Optional[str] = None,
    page: Optional[str] = '1',
    limit: Optional[int] = None,
    namespace: Optional[Namespace] = None,
):
    """
    Listing information about given vulnerability
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/registries',
    description=""" List all configured registries the system can/will watch """,
    tags=['registry_configuration_management'],
)
def list_registries(
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account')
):
    """
    List configured registries
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/registries',
    description=""" Adds a new registry to the system """,
    tags=['registry_configuration_management'],
)
def create_registry(
    validate_: Optional[bool] = Query(None, alias='validate'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: RegistryConfigurationRequest = ...,
):
    """
    Add a new registry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/registries/{registry}',
    description=""" Delete a registry configuration record from the system. Does not remove any images. """,
    tags=['registry_configuration_management', 'credential_operations'],
)
def delete_registry(
    registry: Path,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete a registry configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/registries/{registry}',
    description=""" Get information on a specific registry """,
    tags=['registry_configuration_management'],
)
def get_registry(
    registry: Path,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get a specific registry configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/registries/{registry}',
    description=""" Replaces an existing registry record with the given record """,
    tags=['registry_configuration_management'],
)
def update_registry(
    registry: Path,
    validate_: Optional[bool] = Query(None, alias='validate'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: RegistryConfigurationRequest = ...,
):
    """
    Update/replace a registry configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/repositories', tags=['repository_subscription_operations'])
def add_repository(
    repository: str,
    autosubscribe: Optional[bool] = None,
    dryrun: Optional[bool] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Add repository to watch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/status',
    description=""" Get the API service status """,
    tags=['service_current_status_check', 'system_health_checks'],
)
def get_status():
    """
    Service status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions',
    tags=['repository_subscription_operations', 'subscription_operations_management'],
)
def list_subscriptions(
    subscription_key: Optional[str] = None,
    subscription_type: Optional[str] = None,
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List all subscriptions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/subscriptions',
    description=""" Create a new subscription to watch a tag and get notifications of changes """,
    tags=['repository_subscription_operations', 'subscription_operations_management'],
)
def add_subscription(
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: SubscriptionRequest = ...,
):
    """
    Add a subscription of a specific type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/subscriptions/{subscriptionId}',
    tags=['subscription_operations_management', 'repository_subscription_operations'],
)
def delete_subscription(
    subscription_id: str = Path(..., alias='subscriptionId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Delete subscriptions of a specific type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/subscriptions/{subscriptionId}',
    tags=['repository_subscription_operations', 'subscription_operations_management'],
)
def get_subscription(
    subscription_id: str = Path(..., alias='subscriptionId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    Get a specific subscription set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/subscriptions/{subscriptionId}',
    tags=['subscription_operations_management', 'repository_subscription_operations'],
)
def update_subscription(
    subscription_id: str = Path(..., alias='subscriptionId'),
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
    body: SubscriptionUpdate = ...,
):
    """
    Update an existing and specific subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/summaries/imagetags',
    description=""" List all image tags visible to the user """,
    tags=['image_analysis_management', 'image_metadata_retrieval'],
)
def list_imagetags(
    image_status: Optional[ImageStatus3] = ['active'],
    x_anchore_account: Optional[str] = Header(None, alias='x-anchore-account'),
):
    """
    List all visible image digests and tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system',
    description=""" Get the system status including queue lengths """,
    tags=['system_health_checks', 'service_current_status_check'],
)
def get_service_detail():
    """
    System status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/error_codes',
    description=""" Describe anchore engine error codes. """,
    tags=['error_information_handling'],
)
def describe_error_codes():
    """
    Describe anchore engine error codes.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/feeds',
    description=""" Return a list of feed and their groups along with update and record count information. This data reflects the state of the policy engine, not the upstream feed service itself. """,
    tags=['feed_management_operations'],
)
def get_system_feeds():
    """
    list feeds operations and information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/system/feeds',
    description=""" Execute a synchronous feed sync operation. The response will block until complete, then return the result summary. """,
    tags=['feed_management_operations'],
)
def post_system_feeds(flush: Optional[bool] = None, sync: Optional[bool] = None):
    """
    trigger feeds operations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/system/feeds/{feed}',
    description=""" Delete the groups and data for the feed and disable the feed itself """,
    tags=['feed_management_operations'],
)
def delete_feed(feed: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/system/feeds/{feed}',
    description=""" Disable the feed so that it does not sync on subsequent sync operations """,
    tags=['feed_management_operations'],
)
def toggle_feed_enabled(feed: str, enabled: bool = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/system/feeds/{feed}/{group}',
    description=""" Delete the group data and disable the group itself """,
    tags=['feed_management_operations'],
)
def delete_feed_group(feed: str, group: str = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/system/feeds/{feed}/{group}',
    description=""" Disable a specific group within a feed to not sync """,
    tags=['feed_management_operations'],
)
def toggle_group_enabled(feed: str, group: str = ..., enabled: bool = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/policy_spec',
    description=""" Get the policy language spec for this service """,
    tags=['policy_configuration_management'],
)
def describe_policy():
    """
    Describe the policy language spec implemented by this service.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/services',
    tags=['service_configuration_management', 'system_event_management'],
)
def list_services():
    """
    List system services
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/services/{servicename}',
    tags=['service_configuration_management', 'service_current_status_check'],
)
def get_services_by_name(servicename: str):
    """
    Get a service configuration and state
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/system/services/{servicename}/{hostid}',
    tags=['service_configuration_management', 'credential_operations'],
)
def delete_service(servicename: str, hostid: str = ...):
    """
    Delete the service config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/system/services/{servicename}/{hostid}', tags=['service_configuration_management']
)
def get_services_by_name_and_host(servicename: str, hostid: str = ...):
    """
    Get service config for a specific host
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/system/webhooks/{webhook_type}/test',
    description=""" Loads the Webhook configuration for webhook_type, and sends the notification out as a test """,
    tags=['webhook_functionality_testing'],
)
def test_webhook(
    webhook_type: str, notification_type: Optional[NotificationType] = 'tag_update'
):
    """
    Adds the capabilities to test a webhook delivery for the given notification type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/user', tags=['user_information_management'])
def get_user():
    """
    List authenticated user info
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/credentials', tags=['user_information_management', 'credential_operations']
)
def get_credentials():
    """
    Get current credential summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user/credentials', tags=['user_information_management', 'credential_operations']
)
def add_credential(body: AccessCredential):
    """
    add/replace credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/version',
    description=""" Returns the version object for the service, including db schema version info """,
    tags=[
        'user_information_management',
        'credential_operations',
        'system_event_management',
        'archive_operations',
        'system_health_checks',
        'image_analysis_management',
        'image_metadata_retrieval',
        'image_security_policy_evaluation',
        'import_operations_management',
        'docker_image_import',
        'policy_configuration_management',
        'vulnerability_data_querying',
        'registry_configuration_management',
        'repository_subscription_operations',
        'service_current_status_check',
        'subscription_operations_management',
        'feed_management_operations',
        'service_configuration_management',
        'error_information_handling',
        'webhook_functionality_testing',
    ],
)
def version_check():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
