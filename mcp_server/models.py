# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T14:24:07+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, constr


class Type(Enum):
    password = 'password'


class AccessCredential(BaseModel):
    created_at: Optional[str] = Field(
        None, description='The timestamp of creation of the credential'
    )
    type: Type = Field(..., description='The type of credential')
    value: str = Field(..., description='The credential value (e.g. the password)')


class State(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    deleting = 'deleting'


class Type1(Enum):
    user = 'user'
    admin = 'admin'
    service = 'service'


class Account(BaseModel):
    created_at: Optional[datetime] = Field(
        None, description='The timestamp when the account was created'
    )
    email: Optional[str] = Field(
        None, description='Optional email address associated with the account'
    )
    last_updated: Optional[datetime] = Field(
        None,
        description='The timestamp of the last update to the account metadata itself (not users or creds)',
    )
    name: str = Field(
        ..., description='The account identifier, not updatable after creation'
    )
    state: Optional[State] = Field(
        None,
        description='State of the account. Disabled accounts prevent member users from logging in, deleting accounts are disabled and pending deletion and will be removed once all owned resources are garbage collected by the system',
    )
    type: Optional[Type1] = Field(
        None,
        description="The user type (admin vs user). If not specified in a POST request, 'user' is default",
    )


class AccountCreationRequest(BaseModel):
    email: Optional[
        constr(
            pattern=r'[a-z0-9!#$%&\'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&\'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?'
        )
    ] = Field(
        None,
        description='An optional email to associate with the account for contact purposes',
    )
    name: constr(pattern=r'^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$') = (
        Field(
            ...,
            description='The account name to use. This will identify the account and must be globally unique in the system.',
        )
    )


class AccountList(RootModel[List[Account]]):
    root: List[Account]


class State1(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class AccountStatus(BaseModel):
    state: Optional[State1] = Field(None, description='The status of the account')


class Status(Enum):
    archived = 'archived'
    archiving = 'archiving'
    error = 'error'


class AnalysisArchiveAddResult(BaseModel):
    detail: Optional[str] = Field(
        None, description='Details on the status, e.g. the error message'
    )
    digest: Optional[str] = Field(
        None, description='The image digest requested to be added'
    )
    status: Optional[Status] = Field(
        None,
        description="The status of the archive add operation. Typically either 'archived' or 'error'",
    )


class AnalysisArchiveRulesSummary(BaseModel):
    count: Optional[int] = Field(
        None, description='The number of rules for this account'
    )
    last_updated: Optional[datetime] = Field(
        None, description='The newest last_updated timestamp from the set of rules'
    )


class AnalysisArchiveSource(BaseModel):
    digest: constr(pattern=r'^sha256:[a-fA-F0-9]{64}$') = Field(
        ...,
        description='The image digest identify the analysis. Archived analyses are based on digest, tag records are restored as analysis is restored.',
    )


class AnalysisArchiveSummary(BaseModel):
    last_updated: Optional[datetime] = Field(
        None, description='The timestamp of the most recent archived image'
    )
    total_data_bytes: Optional[int] = Field(
        None,
        description='The total sum of all the bytes stored to the backing storage. Accounts for anchore-applied compression, but not compression by the underlying storage system.',
    )
    total_image_count: Optional[int] = Field(
        None, description='The number of unique images (digests) in the archive'
    )
    total_tag_count: Optional[int] = Field(
        None,
        description='The number of tag records (registry/repo:tag pull strings) in the archive. This may include repeated tags but will always have a unique tag->digest mapping per record.',
    )


class Transition(Enum):
    archive = 'archive'
    delete = 'delete'


class AnalysisArchiveTransitionHistory(BaseModel):
    created_at: Optional[datetime] = None
    imageDigest: Optional[str] = None
    last_updated: Optional[datetime] = None
    rule_id: Optional[str] = None
    transition: Optional[Transition] = None
    transition_task_id: Optional[str] = Field(
        None, description='The task that created & updated this entry'
    )


class AnalysisUpdateEval(BaseModel):
    analysis_status: Optional[str] = None
    annotations: Optional[Dict[str, Any]] = None
    image_digest: Optional[str] = None


class AnchoreErrorCode(BaseModel):
    description: Optional[str] = Field(
        None, description='Description of the error code'
    )
    name: Optional[str] = Field(None, description='Error code name')


class AnalysisStatus(Enum):
    not_analyzed = 'not_analyzed'
    analyzing = 'analyzing'
    analyzed = 'analyzed'
    analysis_failed = 'analysis_failed'


class ImageStatus(Enum):
    active = 'active'
    inactive = 'inactive'
    disabled = 'disabled'


class AnchoreImageTagSummary(BaseModel):
    analysis_status: Optional[str] = None
    analyzed_at: Optional[int] = None
    created_at: Optional[int] = None
    fulltag: Optional[str] = None
    imageDigest: Optional[str] = None
    imageId: Optional[str] = None
    image_status: Optional[str] = None
    parentDigest: Optional[str] = None
    tag_detected_at: Optional[int] = None


class AnchoreImageTagSummaryList(RootModel[List[AnchoreImageTagSummary]]):
    root: List[AnchoreImageTagSummary] = Field(
        ..., description='a list of AnchoreImageTagSummary objects'
    )


class Annotations(BaseModel):
    pass


class ApiErrorResponse(BaseModel):
    code: Optional[int] = None
    detail: Optional[Dict[str, Any]] = Field(
        None,
        description='Details structure for additional information about the error if available. Content and structure will be error specific.',
    )
    error_type: Optional[str] = None
    message: Optional[str] = None


class ArchiveSummary(BaseModel):
    images: Optional[AnalysisArchiveSummary] = None
    rules: Optional[AnalysisArchiveRulesSummary] = None


class Status1(Enum):
    archiving = 'archiving'
    archived = 'archived'
    deleting = 'deleting'
    deleted = 'deleted'


class BaseNotificationData(BaseModel):
    notification_type: Optional[str] = None
    notification_user: Optional[str] = None
    notification_user_email: Optional[str] = None


class CVSSV2Scores(BaseModel):
    base_score: Optional[float] = None
    exploitability_score: Optional[float] = None
    impact_score: Optional[float] = None


class CVSSV3Scores(BaseModel):
    base_score: Optional[float] = None
    exploitability_score: Optional[float] = None
    impact_score: Optional[float] = None


class ContentItem(BaseModel):
    filename: Optional[str] = None
    gid: Optional[int] = None
    linkdest: Optional[str] = None
    mode: Optional[str] = None
    sha256: Optional[str] = None
    size: Optional[int] = None
    type: Optional[str] = None
    uid: Optional[int] = None


class ContentFilesResponse(BaseModel):
    content: Optional[List[ContentItem]] = None
    content_type: Optional[str] = None
    imageDigest: Optional[str] = None


class ContentItem1(BaseModel):
    cpes: Optional[List[str]] = Field(
        None,
        description='A list of Common Platform Enumerations that may uniquely identify the package',
    )
    implementation_version: Optional[str] = Field(None, alias='implementation-version')
    location: Optional[str] = None
    maven_version: Optional[str] = Field(None, alias='maven-version')
    origin: Optional[str] = None
    package: Optional[str] = None
    specification_version: Optional[str] = Field(None, alias='specification-version')
    type: Optional[str] = None


class ContentJAVAPackageResponse(BaseModel):
    content: Optional[List[ContentItem1]] = None
    content_type: Optional[str] = None
    imageDigest: Optional[str] = None


class ContentItem2(BaseModel):
    cpes: Optional[List[str]] = Field(
        None,
        description='A list of Common Platform Enumerations that may uniquely identify the package',
    )
    license: Optional[str] = Field(
        None, description='Deprecated in favor of the \'licenses\' field"'
    )
    licenses: Optional[List[str]] = None
    location: Optional[str] = None
    origin: Optional[str] = None
    package: Optional[str] = None
    size: Optional[str] = None
    type: Optional[str] = None
    version: Optional[str] = None


class ContentPackageResponse(BaseModel):
    content: Optional[List[ContentItem2]] = None
    content_type: Optional[str] = None
    imageDigest: Optional[str] = None


class ContentResponse(BaseModel):
    content: Optional[List[Dict[str, Any]]] = None
    content_type: Optional[str] = None
    imageDigest: Optional[str] = None


class CredentialList(RootModel[List[AccessCredential]]):
    root: List[AccessCredential]


class Status2(Enum):
    not_found = 'not_found'
    deleting = 'deleting'
    delete_failed = 'delete_failed'


class DeleteImageResponse(BaseModel):
    detail: Optional[str] = None
    digest: str
    status: Status2 = Field(..., description='Current status of the image deletion')


class DeleteImageResponseList(RootModel[List[DeleteImageResponse]]):
    root: List[DeleteImageResponse] = Field(
        ..., description='A list of delete image responses'
    )


class EventDescription(BaseModel):
    message: Optional[str] = Field(
        None, description='The message associated with the event type'
    )
    name: Optional[str] = Field(
        None,
        description='The event type. The last component of the fully-qualified event_type (category.subcategory.event)',
    )
    resource_type: Optional[str] = Field(
        None, description='The type of resource this event is generated from'
    )
    type: Optional[str] = Field(
        None,
        description='The fully qualified event type as would be seen in the event payload',
    )


class Resource(BaseModel):
    id: Optional[str] = None
    type: Optional[str] = None
    user_id: Optional[str] = None


class Source(BaseModel):
    base_url: Optional[str] = None
    hostid: Optional[str] = None
    request_id: Optional[str] = None
    servicename: Optional[str] = None


class Event(BaseModel):
    category: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    level: Optional[str] = None
    message: Optional[str] = None
    resource: Optional[Resource] = None
    source: Optional[Source] = None
    timestamp: Optional[datetime] = None
    type: Optional[str] = None


class EventResponse(BaseModel):
    created_at: Optional[datetime] = None
    event: Optional[Event] = None
    generated_uuid: Optional[str] = None


class EventSubcategory(BaseModel):
    description: Optional[str] = None
    events: Optional[List[EventDescription]] = None
    name: Optional[str] = None


class EventsList(BaseModel):
    item_count: Optional[int] = Field(None, description='Number of events in this page')
    next_page: Optional[bool] = Field(
        None,
        description='Boolean flag, True indicates there are more events and False otherwise',
    )
    page: Optional[int] = Field(None, description='Page number of this result set')
    results: Optional[List[EventResponse]] = Field(None, description='List of events')


class FeedGroupMetadata(BaseModel):
    created_at: Optional[datetime] = None
    last_sync: Optional[datetime] = None
    name: Optional[str] = None
    record_count: Optional[int] = None


class FeedMetadata(BaseModel):
    created_at: Optional[datetime] = Field(
        None,
        description='Date the metadata record was created in engine (first seen on source)',
    )
    groups: Optional[List[FeedGroupMetadata]] = None
    last_full_sync: Optional[datetime] = None
    name: Optional[str] = Field(None, description='name of the feed')
    updated_at: Optional[datetime] = Field(
        None, description='Date the metadata was last updated'
    )


class Status3(Enum):
    success = 'success'
    failure = 'failure'


class State2(Enum):
    active = 'active'
    deprecated = 'deprecated'
    eol = 'eol'


class GenericNotificationPayload(BaseModel):
    notificationId: Optional[str] = None
    subscription_key: Optional[str] = None
    subscription_type: Optional[str] = None
    userId: Optional[str] = None


class GroupSyncResult(BaseModel):
    group: Optional[str] = Field(None, description='The name of the group')
    status: Optional[Status3] = None
    total_time_seconds: Optional[float] = Field(
        None, description='The duration of the group sync in seconds'
    )
    updated_image_count: Optional[int] = Field(
        None,
        description="The number of images updated by the this group sync, across all accounts. This is typically only non-zero for vulnerability feeds which update images' vulnerability results during the sync.",
    )
    updated_record_count: Optional[int] = Field(
        None,
        description='The number of feed data records synced down as either updates or new records',
    )


class ImageAnalysisReferences(RootModel[List[str]]):
    root: List[str] = Field(..., description='List of image digests to archive')


class ImageAnalysisReport(BaseModel):
    pass


class ImageContent(BaseModel):
    pass


class ImageContentDeleteResponse(BaseModel):
    pass


class ImageDetail(BaseModel):
    created_at: Optional[datetime] = None
    dockerfile: Optional[str] = None
    fulldigest: Optional[str] = Field(
        None,
        description='Full docker-pullable digest string including the registry url and repository necessary get the image',
    )
    fulltag: Optional[str] = Field(
        None, description='Full docker-pullable tag string referencing the image'
    )
    imageDigest: Optional[str] = Field(
        None, description='The parent Anchore Image record to which this detail maps'
    )
    imageId: Optional[str] = None
    last_updated: Optional[datetime] = None
    registry: Optional[str] = None
    repo: Optional[str] = None
    userId: Optional[str] = None


class ImageFilter(BaseModel):
    digest: Optional[str] = None
    tag: Optional[str] = None


class ImageImportContentResponse(BaseModel):
    created_at: Optional[datetime] = None
    digest: Optional[str] = None


class Status5(Enum):
    pending = 'pending'
    queued = 'queued'
    processing = 'processing'
    complete = 'complete'
    failed = 'failed'
    expired = 'expired'


class ImageImportOperation(BaseModel):
    created_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    status: Optional[Status5] = None
    uuid: Optional[str] = None


class ImageImports(RootModel[List[ImageImportOperation]]):
    root: List[ImageImportOperation]


class Type2(Enum):
    tag = 'tag'
    digest = 'digest'
    id = 'id'


class ImageRef(BaseModel):
    type: Type2
    value: str


class ImageSelectionRule(BaseModel):
    id: Optional[str] = None
    image: ImageRef
    name: str
    registry: str
    repository: str


class ImageSelector(BaseModel):
    registry: Optional[str] = Field(
        None,
        description='The registry section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "docker.io"',
    )
    repository: Optional[str] = Field(
        None,
        description='The repository section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "anchore/anchore-engine"',
    )
    tag: Optional[str] = Field(
        None,
        description='The tag-only section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "latest"',
    )


class ImportContentDigestList(RootModel[List[str]]):
    root: List[str]


class ImportContentDigests(BaseModel):
    dockerfile: Optional[str] = Field(
        None, description='Digest for reference content for dockerfile'
    )
    image_config: str = Field(
        ..., description='Digest for reference content for image config'
    )
    manifest: str = Field(
        ..., description='Digest to reference content for the image manifest'
    )
    packages: str = Field(..., description='Digest to use for the packages content')
    parent_manifest: Optional[str] = Field(
        None, description='Digest for reference content for parent manifest'
    )


class ImportDescriptor(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str
    version: str


class ImportDistribution(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    idLike: str
    name: str
    version: str


class ImportPackageLocation(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    layerID: Optional[str] = None
    path: str


class ImportPackageRelationship(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    child: str
    metadata: Optional[Dict[str, Any]] = None
    parent: str
    type: str


class ImportSchema(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    url: str
    version: str


class ImportSource(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    target: Any
    type: str


class LocalAnalysisSource(BaseModel):
    digest: Optional[str] = None


class Finding(BaseModel):
    path: Optional[str] = Field(
        None, description="A path for a file in the image's rootfs"
    )
    signature: Optional[str] = Field(
        None, description='The malware signature found at the path'
    )


class MalwareScan(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='Indicates if the scanner is enabled'
    )
    findings: Optional[List[Finding]] = None
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Open schema for scanner-specific metadata related to the scan result',
    )
    scanner: Optional[str] = Field(
        None, description='The name of the scanner that produced the finding'
    )


class MappingRule(BaseModel):
    id: Optional[str] = None
    image: ImageRef
    name: str
    policy_id: Optional[str] = Field(
        None,
        description='Optional single policy to evalute, if set will override any value in policy_ids, for backwards compatibility. Generally, policy_ids should be used even with a array of length 1.',
    )
    policy_ids: Optional[List[str]] = Field(
        None, description='List of policyIds to evaluate in order, to completion'
    )
    registry: str
    repository: str
    whitelist_ids: Optional[List[str]] = None


class MetadataResponse(BaseModel):
    imageDigest: Optional[str] = None
    metadata: Optional[Any] = None
    metadata_type: Optional[str] = None


class NativeSbom(BaseModel):
    pass


class NotificationBase(BaseModel):
    created_at: Optional[int] = None
    dataId: Optional[str] = None
    last_updated: Optional[int] = None
    max_tries: Optional[int] = None
    queueId: Optional[str] = None
    record_state_key: Optional[str] = 'active'
    record_state_val: Optional[str] = None
    tries: Optional[int] = None
    userId: Optional[str] = None


class NvdDataObject(BaseModel):
    cvss_v2: Optional[CVSSV2Scores] = None
    cvss_v3: Optional[CVSSV3Scores] = None
    id: Optional[str] = Field(None, description='NVD Vulnerability ID')


class PackageReference(BaseModel):
    name: Optional[str] = Field(None, description='Package name')
    type: Optional[str] = Field(
        None,
        description='Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)',
    )
    version: Optional[str] = Field(
        None,
        description='A version for the package. If null, then references all versions',
    )
    will_not_fix: Optional[bool] = Field(
        None, description='Whether a vendor will or will not fix a vulnerabitlity'
    )


class PaginationProperties(BaseModel):
    next_page: Optional[str] = Field(
        None,
        description='True if additional pages exist (page + 1) or False if this is the last page',
    )
    page: Optional[str] = Field(
        None,
        description='The page number returned (should match the requested page query string param)',
    )
    returned_count: Optional[int] = Field(
        None, description='The number of items sent in this response'
    )


class PolicyEvalNotificationPayload(GenericNotificationPayload):
    annotations: Optional[Dict[str, Any]] = Field(
        None, description='List of Corresponding Image Annotations'
    )
    curr_eval: Optional[Dict[str, Any]] = Field(
        None, description='The Current Policy Evaluation result'
    )
    last_eval: Optional[Dict[str, Any]] = Field(
        None, description='The Previous Policy Evaluation result'
    )


class PolicyEvaluation(BaseModel):
    pass


class PolicyEvaluationList(RootModel[List[PolicyEvaluation]]):
    root: List[PolicyEvaluation] = Field(..., description='Evaluation response object')


class Action(Enum):
    GO = 'GO'
    STOP = 'STOP'
    WARN = 'WARN'


class Param(BaseModel):
    name: str
    value: str


class PolicyRule(BaseModel):
    action: Action
    gate: str
    id: Optional[str] = None
    params: Optional[List[Param]] = None
    trigger: str


class RegexContentMatch(BaseModel):
    lines: Optional[List[int]] = Field(
        None, description='A list of line numbers in the file that matched the regex'
    )
    name: Optional[str] = Field(
        None, description='The name associated with the regular expression'
    )
    regex: Optional[str] = Field(
        None, description='The regular expression used for the match'
    )


class RegistryConfiguration(BaseModel):
    created_at: Optional[datetime] = None
    last_upated: Optional[datetime] = None
    registry: Optional[str] = Field(
        None,
        description='hostname:port string for accessing the registry, as would be used in a docker pull operation',
    )
    registry_name: Optional[str] = Field(
        None, description='human readable name associated with registry record'
    )
    registry_type: Optional[str] = Field(None, description='Type of registry')
    registry_user: Optional[str] = Field(
        None, description='Username portion of credential to use for this registry'
    )
    registry_verify: Optional[bool] = Field(
        None, description='Use TLS/SSL verification for the registry URL'
    )
    userId: Optional[str] = Field(
        None, description='Engine user that owns this registry entry'
    )


class RegistryConfigurationList(RootModel[List[RegistryConfiguration]]):
    root: List[RegistryConfiguration] = Field(
        ..., description='List of registry configurations'
    )


class RegistryConfigurationRequest(BaseModel):
    registry: Optional[str] = Field(
        None,
        description='hostname:port string for accessing the registry, as would be used in a docker pull operation. May include some or all of a repository and wildcards (e.g. docker.io/library/* or gcr.io/myproject/myrepository)',
    )
    registry_name: Optional[str] = Field(
        None, description='human readable name associated with registry record'
    )
    registry_pass: Optional[str] = Field(
        None, description='Password portion of credential to use for this registry'
    )
    registry_type: Optional[str] = Field(None, description='Type of registry')
    registry_user: Optional[str] = Field(
        None, description='Username portion of credential to use for this registry'
    )
    registry_verify: Optional[bool] = Field(
        None, description='Use TLS/SSL verification for the registry URL'
    )


class RegistryDigestSource(BaseModel):
    creation_timestamp_override: Optional[datetime] = Field(
        None,
        description='Optional override of the image creation time to support proper tag history construction in cases of out-of-order analysis compared to registry history for the tag',
    )
    dockerfile: Optional[constr(pattern=r'^[a-zA-Z0-9+/=]+$')] = Field(
        None,
        description='Base64 encoded content of the dockerfile used to build the image, if available.',
    )
    pullstring: str = Field(
        ...,
        description='A digest-based pullstring (e.g. docker.io/nginx@sha256:123abc)',
    )
    tag: str = Field(
        ...,
        description='A valid docker tag reference (e.g. docker.io/nginx:latest) that will be associated with the image but not used to pull the image.',
    )


class RegistryTagSource(BaseModel):
    dockerfile: Optional[constr(pattern=r'^[a-zA-Z0-9+/=]+$')] = Field(
        None,
        description='Base64 encoded content of the dockerfile used to build the image, if available.',
    )
    pullstring: str = Field(
        ...,
        description='A docker pull string (e.g. docker.io/nginx:latest, or docker.io/nginx@sha256:abd) to retrieve the image',
    )


class RepositoryTagList(RootModel[List[str]]):
    root: List[str] = Field(..., description='List of discovered tags in a repository')


class RetrievedFile(BaseModel):
    b64_content: Optional[str] = None
    path: Optional[str] = None


class RetrievedFileList(RootModel[List[RetrievedFile]]):
    root: List[RetrievedFile] = Field(
        ..., description='Simple array of RetrievedFileMetadata objects'
    )


class SecretSearchResult(BaseModel):
    matches: Optional[List[RegexContentMatch]] = None
    path: Optional[str] = None


class Api(BaseModel):
    version: Optional[str] = Field(None, description='Semantic version of the api')


class Db(BaseModel):
    schema_version: Optional[str] = Field(
        None, description='Semantic version of the db schema'
    )


class Service1(BaseModel):
    version: Optional[str] = Field(
        None, description='Semantic Version string of the service implementation'
    )


class ServiceVersion(BaseModel):
    api: Optional[Api] = Field(None, description='Api Version string')
    db: Optional[Db] = None
    service: Optional[Service1] = None


class Severity(Enum):
    Unknown = 'Unknown'
    Negligible = 'Negligible'
    Low = 'Low'
    Medium = 'Medium'
    High = 'High'
    Critical = 'Critical'


class StatusResponse(BaseModel):
    available: Optional[bool] = None
    busy: Optional[bool] = None
    db_version: Optional[str] = None
    detail: Optional[Dict[str, Any]] = None
    message: Optional[str] = None
    up: Optional[bool] = None
    version: Optional[str] = None


class Subscription(BaseModel):
    active: Optional[bool] = Field(
        None, description='Is the subscription currently active'
    )
    subscription_id: Optional[str] = Field(
        None, description='the unique id for this subscription record'
    )
    subscription_key: Optional[str] = Field(
        None,
        description='The key value that the subscription references. E.g. a tag value or a repo name.',
    )
    subscription_type: Optional[str] = Field(
        None, description='The type of the subscription'
    )
    subscription_value: Optional[str] = Field(
        None, description='The value of the subscription target'
    )
    userId: Optional[str] = Field(None, description='The userId of the subscribed user')


class SubscriptionList(RootModel[List[Subscription]]):
    root: List[Subscription] = Field(..., description='List of subscriptions')


class SubscriptionRequest(BaseModel):
    subscription_key: Optional[str] = None
    subscription_type: Optional[str] = None
    subscription_value: Optional[str] = None


class SubscriptionUpdate(BaseModel):
    active: Optional[bool] = Field(
        None, description='Toggle the subscription processing on or off'
    )
    subscription_value: Optional[str] = Field(
        None,
        description='The new subscription value, e.g. the new tag to be subscribed to',
    )


class TagEntry(BaseModel):
    detected_at: Optional[datetime] = Field(
        None,
        description='The timestamp at which the Anchore Engine detected this tag was mapped to the image digest. Does not necessarily indicate when the tag was actually pushed to the registry.',
    )
    pullstring: Optional[str] = Field(
        None,
        description='The pullable string for the tag. E.g. "docker.io/library/node:latest"',
    )
    registry: Optional[str] = Field(
        None, description='The registry hostname:port section of the pull string'
    )
    repository: Optional[str] = Field(
        None, description='The repository section of the pull string'
    )
    tag: Optional[str] = Field(
        None, description='The tag-only section of the pull string'
    )


class TagUpdateNotificationPayload(GenericNotificationPayload):
    annotations: Optional[Dict[str, Any]] = Field(
        None, description='List of Corresponding Image Annotations'
    )
    curr_eval: Optional[List] = Field(
        None, description='A list containing the current image digest'
    )
    last_eval: Optional[List] = Field(
        None, description='A list containing the previous image digests'
    )


class TokenResponse(BaseModel):
    token: str = Field(..., description='The token content')


class TriggerParamSpec(BaseModel):
    description: Optional[str] = None
    example: Optional[str] = Field(
        None,
        description='An example value for the parameter (encoded as a string if the parameter is an object or list type)',
    )
    name: Optional[str] = Field(
        None, description='Parameter name as it appears in policy document'
    )
    required: Optional[bool] = Field(
        None, description='Is this a required parameter or optional'
    )
    state: Optional[State2] = Field(None, description='State of the trigger parameter')
    superceded_by: Optional[str] = Field(
        None,
        description='The name of another trigger that supercedes this on functionally if this is deprecated',
    )
    validator: Optional[Dict[str, Any]] = Field(
        None,
        description='If present, a definition for validation of input. Typically a jsonschema object that can be used to validate an input against.',
    )


class TriggerSpec(BaseModel):
    description: Optional[str] = Field(
        None,
        description='Trigger description for what it tests and when it will fire during evaluation',
    )
    name: Optional[str] = Field(
        None, description='Name of the trigger as it would appear in a policy document'
    )
    parameters: Optional[List[TriggerParamSpec]] = Field(
        None, description='The list of parameters that are valid for this trigger'
    )
    state: Optional[State2] = Field(None, description='State of the trigger')
    superceded_by: Optional[str] = Field(
        None,
        description='The name of another trigger that supercedes this on functionally if this is deprecated',
    )


class Type3(Enum):
    native = 'native'
    internal = 'internal'
    external = 'external'


class User(BaseModel):
    created_at: Optional[datetime] = Field(
        None, description='The timestampt the user record was created'
    )
    last_updated: Optional[datetime] = Field(
        None, description='The timestamp of the last update to this record'
    )
    source: Optional[str] = Field(
        None,
        description='If the user is external, this is the source that the user was initialized from. All other user types have this set to null',
    )
    type: Optional[Type3] = Field(None, description="The user's type")
    username: str = Field(..., description='The username to authenticate with')


class UserCreationRequest(BaseModel):
    password: constr(pattern=r'.{6,128}$') = Field(
        ...,
        description='The initial password for the user, must be at least 6 characters, up to 128',
    )
    username: constr(
        pattern=r'^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$'
    ) = Field(..., description='The username to create')


class UserList(RootModel[List[User]]):
    root: List[User]


class VendorDataObject(BaseModel):
    cvss_v2: Optional[CVSSV2Scores] = None
    cvss_v3: Optional[CVSSV3Scores] = None
    id: Optional[str] = Field(None, description='Vendor Vulnerability ID')


class VulnDiffResult(BaseModel):
    added: Optional[List] = None
    removed: Optional[List] = None
    updated: Optional[List] = None


class VulnUpdateNotificationPayload(GenericNotificationPayload):
    annotations: Optional[Dict[str, Any]] = Field(
        None, description='List of Corresponding Image Annotations'
    )
    diff_vulnerability_result: Optional[VulnDiffResult] = None
    imageDigest: Optional[str] = None


class VulnerabilityReference(BaseModel):
    source: Optional[str] = Field(None, description='The reference source')
    tags: Optional[List[str]] = None
    url: Optional[str] = Field(None, description='The reference url')


class VulnerablePackageReference(BaseModel):
    name: Optional[str] = Field(None, description='Package name')
    namespace: Optional[str] = Field(
        None, description='Vulnerability namespace of affected package'
    )
    severity: Optional[str] = Field(
        None, description='Severity of vulnerability affecting package'
    )
    type: Optional[str] = Field(
        None,
        description='Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)',
    )
    version: Optional[str] = Field(
        None,
        description='A version for the package. If null, then references all versions',
    )


class WhitelistItem(BaseModel):
    expires_on: Optional[datetime] = None
    gate: str
    id: Optional[str] = None
    trigger_id: str


class State5(Enum):
    enabled = 'enabled'
    disabled = 'disabled'
    deleting = 'deleting'


class AccountsAccountnameUsersGetResponse(RootModel[List[User]]):
    root: List[User] = Field(..., description='List of user credential records')


class CredentialType(Enum):
    password = 'password'


class EventsDeleteResponse(RootModel[List[str]]):
    root: List[str]


class ImageDigests(RootModel[List[str]]):
    root: List[str]


class ImageStatus1(Enum):
    all = 'all'
    active = 'active'
    deleting = 'deleting'


class AnalysisStatus1(Enum):
    not_analyzed = 'not_analyzed'
    analyzed = 'analyzed'
    analyzing = 'analyzing'
    analysis_failed = 'analysis_failed'


class ImagesByIdImageIdContentGetResponse(RootModel[List[str]]):
    root: List[str]


class ImagesByIdImageIdVulnGetResponseEnum(Enum):
    all = 'all'
    os = 'os'
    non_os = 'non-os'


class ImagesByIdImageIdVulnGetResponse(
    RootModel[List[ImagesByIdImageIdVulnGetResponseEnum]]
):
    root: List[ImagesByIdImageIdVulnGetResponseEnum]


class ImagesImageDigestContentGetResponse(RootModel[List[str]]):
    root: List[str]


class ImagesImageDigestMetadataGetResponse(RootModel[List[str]]):
    root: List[str]


class ImagesImageDigestVulnGetResponseEnum(Enum):
    all = 'all'
    os = 'os'
    non_os = 'non-os'


class ImagesImageDigestVulnGetResponse(
    RootModel[List[ImagesImageDigestVulnGetResponseEnum]]
):
    root: List[ImagesImageDigestVulnGetResponseEnum]


class ImportImagesPostRequest(BaseModel):
    archive_file: bytes = Field(..., description='anchore image tar archive.')


class ImportsImagesOperationIdImageConfigPostRequest(BaseModel):
    pass


class ImportsImagesOperationIdManifestPostRequest(BaseModel):
    pass


class ImportsImagesOperationIdParentManifestPostRequest(BaseModel):
    pass


class OauthTokenPostRequest(BaseModel):
    client_id: Optional[str] = Field(
        'anonymous', description='The type of client used for the OAuth token'
    )
    grant_type: Optional[str] = Field(
        'password', description='OAuth Grant type for token'
    )
    password: Optional[str] = Field(None, description='Password for corresponding user')
    username: Optional[str] = Field(None, description='User to assign OAuth token to')


class Id(RootModel[List[str]]):
    root: List[str]


class Namespace(RootModel[List[str]]):
    root: List[str]


class ImageStatu(Enum):
    all = 'all'
    active = 'active'
    deleting = 'deleting'


class ImageStatus3(RootModel[List[ImageStatu]]):
    root: List[ImageStatu]


class SystemErrorCodesGetResponse(RootModel[List[AnchoreErrorCode]]):
    root: List[AnchoreErrorCode] = Field(
        ..., description='List of Error Code Descriptions'
    )


class SystemFeedsGetResponse(RootModel[List[FeedMetadata]]):
    root: List[FeedMetadata]


class SystemFeedsFeedGroupPutResponse(RootModel[List[FeedMetadata]]):
    root: List[FeedMetadata]


class NotificationType(Enum):
    tag_update = 'tag_update'
    analysis_update = 'analysis_update'
    vuln_update = 'vuln_update'
    policy_eval = 'policy_eval'


class AddAnalysisArchiveResult(RootModel[List[AnalysisArchiveAddResult]]):
    root: List[AnalysisArchiveAddResult] = Field(
        ..., description='List of analysis archive add results'
    )


class AnalysisArchiveTransitionRuleExclude(BaseModel):
    expiration_days: Optional[int] = Field(
        -1,
        description='How long the image selected will be excluded from the archive transition',
    )
    selector: Optional[ImageSelector] = None


class AnalysisUpdateNotificationPayload(GenericNotificationPayload):
    annotations: Optional[Dict[str, Any]] = Field(
        None, description='List of Corresponding Image Annotations'
    )
    curr_eval: Optional[AnalysisUpdateEval] = None
    last_eval: Optional[AnalysisUpdateEval] = None


class AnchoreImage(BaseModel):
    analysis_status: Optional[AnalysisStatus] = Field(
        None,
        description='A state value for the current status of the analysis progress of the image',
    )
    annotations: Optional[Dict[str, Any]] = None
    created_at: Optional[datetime] = None
    imageDigest: Optional[str] = None
    image_content: Optional[ImageContent] = None
    image_detail: Optional[List[ImageDetail]] = Field(
        None,
        description='Details specific to an image reference and type such as tag and image source',
    )
    image_status: Optional[ImageStatus] = Field(None, description='State of the image')
    last_updated: Optional[datetime] = None
    record_version: Optional[str] = Field(
        None,
        description='The version of the record, used for internal schema updates and data migrations.',
    )
    userId: Optional[str] = None


class AnchoreImageList(RootModel[List[AnchoreImage]]):
    root: List[AnchoreImage] = Field(..., description='A list of Anchore Images')


class ArchivedAnalysis(BaseModel):
    analyzed_at: Optional[datetime] = None
    annotations: Optional[Dict[str, Any]] = Field(
        None, description='User provided annotations as key-value pairs'
    )
    archive_size_bytes: Optional[int] = Field(
        None, description='The size, in bytes, of the analysis archive file'
    )
    created_at: Optional[datetime] = None
    imageDigest: Optional[str] = Field(
        None,
        description='The image digest (digest of the manifest describing the image, per docker spec)',
    )
    image_detail: Optional[List[TagEntry]] = Field(
        None, description='List of tags associated with the image digest'
    )
    last_updated: Optional[datetime] = None
    parentDigest: Optional[str] = Field(
        None, description='The digest of a parent manifest (for manifest-list images)'
    )
    status: Optional[Status1] = Field(None, description='The archival status')


class ContentMalwareResponse(BaseModel):
    content: Optional[List[MalwareScan]] = Field(
        None,
        description='List of malware scan results, one per scanner configured to run',
    )
    content_type: Optional[str] = None
    imageDigest: Optional[str] = None


class EventCategory(BaseModel):
    category: Optional[str] = None
    description: Optional[str] = None
    subcategories: Optional[List[EventSubcategory]] = None


class EventTypesList(RootModel[List[EventCategory]]):
    root: List[EventCategory] = Field(..., description='Array of EventCategory objects')


class FeedSyncResult(BaseModel):
    feed: Optional[str] = Field(None, description='The name of the feed synced')
    groups: Optional[List[GroupSyncResult]] = Field(
        None, description='Array of group sync results'
    )
    status: Optional[Status3] = Field(
        None, description='The result of the sync operations, either co'
    )
    total_time_seconds: Optional[float] = Field(
        None,
        description='The duratin, in seconds, of the sync of the feed, the sum of all the group syncs',
    )


class FeedSyncResults(RootModel[List[FeedSyncResult]]):
    root: List[FeedSyncResult] = Field(
        ...,
        description='An array of feed sync summaries representing the result of an explicit feed sync operation',
    )


class FileContentSearchResult(BaseModel):
    matches: Optional[List[RegexContentMatch]] = None
    path: Optional[str] = None


class GateSpec(BaseModel):
    description: Optional[str] = Field(None, description='Description of the gate')
    name: Optional[str] = Field(
        None, description='Gate name, as it would appear in a policy document'
    )
    state: Optional[State2] = Field(
        None,
        description="State of the gate and transitively all triggers it contains if not 'active'",
    )
    superceded_by: Optional[str] = Field(
        None,
        description='The name of another trigger that supercedes this on functionally if this is deprecated',
    )
    triggers: Optional[List[TriggerSpec]] = Field(
        None, description='List of the triggers that can fire for this Gate'
    )


class ImageImportManifest(BaseModel):
    contents: ImportContentDigests
    digest: str
    local_image_id: Optional[str] = Field(
        None, description='An "imageId" as used by Docker if available'
    )
    operation_uuid: str
    parent_digest: Optional[str] = Field(
        None,
        description="The digest of the images's manifest-list parent if it was accessed from a multi-arch tag where the tag pointed to a manifest-list. This allows preservation of that relationship in the data",
    )
    tags: List[str]


class ImageReference(BaseModel):
    analyzed_at: Optional[str] = Field(
        None,
        description="Timestamp, in rfc3339 format, indicating when the image state became 'analyzed' in Anchore Engine.",
    )
    digest: Optional[str] = Field(None, description='The image digest')
    id: Optional[str] = Field(None, description='The image id if available')
    tag_history: Optional[List[TagEntry]] = None


class ImageSource(BaseModel):
    archive: Optional[AnalysisArchiveSource] = None
    digest: Optional[RegistryDigestSource] = None
    import_: Optional[ImageImportManifest] = Field(None, alias='import')
    tag: Optional[RegistryTagSource] = None


class ImageWithPackages(BaseModel):
    image: Optional[ImageReference] = None
    packages: Optional[List[PackageReference]] = None


class ImportPackage(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    cpes: List[str]
    foundBy: Optional[str] = None
    id: Optional[str] = None
    language: str
    licenses: List[str]
    locations: List[ImportPackageLocation]
    metadata: Optional[Dict[str, Any]] = None
    metadataType: str
    name: str
    purl: Optional[str] = None
    type: str
    version: str


class NvdDataList(RootModel[List[NvdDataObject]]):
    root: List[NvdDataObject] = Field(..., description='List of Nvd Data objects')


class PaginatedImageList(PaginationProperties):
    images: Optional[List[ImageWithPackages]] = None


class Policy(BaseModel):
    comment: Optional[str] = None
    id: str
    name: Optional[str] = None
    rules: Optional[List[PolicyRule]] = None
    version: str


class PolicyEvalNotificationData(BaseNotificationData):
    notification_payload: Optional[PolicyEvalNotificationPayload] = None


class SecretSearchList(RootModel[List[SecretSearchResult]]):
    root: List[SecretSearchResult] = Field(
        ..., description='Simple array of RetrievedFileMetadata objects'
    )


class Service(BaseModel):
    base_url: Optional[str] = Field(
        None, description='The url to reach the service, including port as needed'
    )
    hostid: Optional[str] = Field(
        None, description='The unique id of the host on which the service is executing'
    )
    service_detail: Optional[StatusResponse] = None
    servicename: Optional[str] = Field(None, description='Registered service name')
    status: Optional[bool] = None
    status_message: Optional[str] = Field(
        None,
        description="A state indicating the condition of the service. Normal operation is 'registered'",
    )
    version: Optional[str] = Field(
        None,
        description='The version of the service as reported by the service implementation on registration',
    )


class ServiceList(RootModel[List[Service]]):
    root: List[Service] = Field(..., description='A list of service objects')


class SystemStatusResponse(BaseModel):
    service_states: Optional[ServiceList] = None


class TagUpdateNotificationData(BaseNotificationData):
    notification_payload: Optional[TagUpdateNotificationPayload] = None


class VendorDataList(RootModel[List[VendorDataObject]]):
    root: List[VendorDataObject] = Field(..., description='List of Vendor Data objects')


class VulnUpdateNotificationData(BaseNotificationData):
    notification_payload: Optional[VulnUpdateNotificationPayload] = None


class Vulnerability(BaseModel):
    feed: Optional[str] = Field(
        None, description='The name of the feed where vulnerability match was made'
    )
    feed_group: Optional[str] = Field(
        None,
        description='The name of the feed group where vulnerability match was made',
    )
    fix: Optional[str] = Field(
        None, description='The package containing a fix, if available'
    )
    nvd_data: Optional[NvdDataList] = None
    package: Optional[str] = Field(
        None,
        description='The package name and version that are vulnerable in the image',
    )
    package_cpe: Optional[str] = Field(
        None,
        description='The CPE string (if applicable) describing the package to vulnerability match',
    )
    package_name: Optional[str] = Field(
        None, description='The name of the vulnerable package artifact'
    )
    package_path: Optional[str] = Field(
        None,
        description='The location (if applicable) of the vulnerable package in the container filesystem',
    )
    package_type: Optional[str] = Field(
        None, description='The type of vulnerable package'
    )
    package_version: Optional[str] = Field(
        None, description='The version of the vulnerable package artifact'
    )
    severity: Optional[str] = Field(
        None, description='The severity of the vulnerability'
    )
    url: Optional[str] = Field(
        None, description='The url for more information about the vulnerability'
    )
    vendor_data: Optional[VendorDataList] = None
    vuln: Optional[str] = Field(
        None,
        description='The vulnerability identifier, such as CVE-2017-100, or RHSA-2017123',
    )
    will_not_fix: Optional[bool] = Field(
        None, description='Whether a vendor will fix or not fix the vulnerability'
    )


class VulnerabilityList(RootModel[List[Vulnerability]]):
    root: List[Vulnerability] = Field(..., description='List of Vulnerability objects')


class VulnerabilityResponse(BaseModel):
    imageDigest: Optional[str] = None
    vulnerabilities: Optional[VulnerabilityList] = None
    vulnerability_type: Optional[str] = None


class VulnerableImage(BaseModel):
    affected_packages: Optional[List[VulnerablePackageReference]] = None
    image: Optional[ImageReference] = None


class Whitelist(BaseModel):
    comment: Optional[str] = None
    id: str
    items: Optional[List[WhitelistItem]] = None
    name: Optional[str] = None
    version: str


class SystemPolicySpecGetResponse(RootModel[List[GateSpec]]):
    root: List[GateSpec] = Field(..., description='List of Gate specifications')


class AnalysisArchiveTransitionRule(BaseModel):
    analysis_age_days: Optional[int] = Field(
        None,
        description='Matches if the analysis is strictly older than this number of days',
    )
    created_at: Optional[datetime] = None
    exclude: Optional[AnalysisArchiveTransitionRuleExclude] = None
    last_updated: Optional[datetime] = None
    max_images_per_account: Optional[int] = Field(
        None,
        description='This is the maximum number of image analyses an account can have. Can only be set on system_global rules',
    )
    rule_id: Optional[str] = Field(
        None, description='Unique identifier for archive rule'
    )
    selector: Optional[ImageSelector] = None
    system_global: Optional[bool] = Field(
        None,
        description='True if the rule applies to all accounts in the system. This is only available to admin users to update/modify, but all users with permission to list rules can see them',
    )
    tag_versions_newer: Optional[int] = Field(
        None, description='Number of images mapped to the tag that are newer'
    )
    transition: Transition = Field(
        ...,
        description='The type of transition to make. If "archive", then archive an image from the working set and remove it from the working set. If "delete", then match against archived images and delete from the archive if match.',
    )


class AnalysisUpdateNotificationData(BaseNotificationData):
    notification_payload: Optional[AnalysisUpdateNotificationPayload] = None


class ArchivedAnalyses(RootModel[List[ArchivedAnalysis]]):
    root: List[ArchivedAnalysis] = Field(..., description='List of archived analyses')


class FileContentSearchList(RootModel[List[FileContentSearchResult]]):
    root: List[FileContentSearchResult] = Field(
        ..., description='Simple array of RetrievedFileMetadata objects'
    )


class ImageAnalysisRequest(BaseModel):
    annotations: Optional[Dict[str, Any]] = Field(
        None,
        description='Annotations to be associated with the added image in key/value form',
    )
    created_at: Optional[datetime] = Field(
        None,
        description="Optional override of the image creation time, only honored when both tag and digest are also supplied  e.g. 2018-10-17T18:14:00Z. Deprecated in favor of the 'source' field",
    )
    digest: Optional[str] = Field(
        None,
        description="A digest string for an image, maybe a pull string or just a digest. e.g. nginx@sha256:123 or sha256:abc123. If a pull string, it must have same regisry/repo as the tag field. Deprecated in favor of the 'source' field",
    )
    dockerfile: Optional[constr(pattern=r'^[a-zA-Z0-9+/=]+$')] = Field(
        None,
        description="Base64 encoded content of the dockerfile for the image, if available. Deprecated in favor of the 'source' field.",
    )
    image_type: Optional[str] = Field(
        None,
        description='Optional. The type of image this is adding, defaults to "docker". This can be ommitted until multiple image types are supported.',
    )
    source: Optional[ImageSource] = None
    tag: Optional[str] = Field(
        None,
        description="Full pullable tag reference for image. e.g. docker.io/nginx:latest. Deprecated in favor of the 'source' field",
    )


class ImagePackageManifest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    artifactRelationships: Optional[List[ImportPackageRelationship]] = None
    artifacts: List[ImportPackage]
    descriptor: Optional[ImportDescriptor] = None
    distro: ImportDistribution
    schema_: Optional[ImportSchema] = Field(None, alias='schema')
    source: ImportSource


class PaginatedVulnerableImageList(PaginationProperties):
    images: Optional[List[VulnerableImage]] = None


class PolicyBundle(BaseModel):
    blacklisted_images: Optional[List[ImageSelectionRule]] = Field(
        None,
        description='List of mapping rules that define which images should always result in a STOP/FAIL policy result regardless of policy content or presence in whitelisted_images',
    )
    comment: Optional[str] = Field(
        None, description='Description of the bundle, human readable'
    )
    id: str = Field(..., description='Id of the bundle')
    mappings: List[MappingRule] = Field(
        ...,
        description='Mapping rules for defining which policy and whitelist(s) to apply to an image based on a match of the image tag or id. Evaluated in order.',
    )
    name: Optional[str] = Field(None, description='Human readable name for the bundle')
    policies: List[Policy] = Field(
        ...,
        description='Policies which define the go/stop/warn status of an image using rule matches on image properties',
    )
    version: str = Field(..., description='Version id for this bundle format')
    whitelisted_images: Optional[List[ImageSelectionRule]] = Field(
        None,
        description='List of mapping rules that define which images should always be passed (unless also on the blacklist), regardless of policy result.',
    )
    whitelists: Optional[List[Whitelist]] = Field(
        None,
        description='Whitelists which define which policy matches to disregard explicitly in the final policy decision',
    )


class PolicyBundleRecord(BaseModel):
    active: Optional[bool] = Field(
        None,
        description='True if the bundle is currently defined to be used automatically',
    )
    created_at: Optional[datetime] = None
    last_updated: Optional[datetime] = None
    policyId: Optional[str] = Field(None, description="The bundle's identifier")
    policy_source: Optional[str] = Field(
        None, description='Source location of where the policy bundle originated'
    )
    policybundle: Optional[PolicyBundle] = None
    userId: Optional[str] = Field(
        None, description='UserId of the user that owns the bundle'
    )


class PolicyEvalNotification(NotificationBase):
    data: Optional[PolicyEvalNotificationData] = None


class StandaloneVulnerability(BaseModel):
    affected_packages: Optional[List[PackageReference]] = Field(
        None,
        description='The array of packages (typically packages) that are vulnerable-to or provide fixes-for this vulnerability',
    )
    description: Optional[str] = Field(
        None, description='Description of the vulnerability if available'
    )
    id: Optional[str] = Field(
        None,
        description='Vulnerability identifier. May be CVE-X, RHSA-X, etc. Not necessarily unique across namespaces',
    )
    link: Optional[str] = Field(
        None,
        description='URL for the upstream CVE record in the reporting source (e.g. ubuntu security tracker)',
    )
    namespace: Optional[str] = Field(
        None,
        description='The namespace for the vulnerability record to avoid conflicts for the same id in different distros or sources (e.g. deb vs ubuntu for same CVE)',
    )
    nvd_data: Optional[NvdDataList] = None
    references: Optional[List[VulnerabilityReference]] = Field(
        None, description='List of references including'
    )
    severity: Optional[Severity] = Field(
        None, description='Severity label specific to the namepsace'
    )
    vendor_data: Optional[VendorDataList] = None


class TagUpdateNotification(NotificationBase):
    data: Optional[TagUpdateNotificationData] = None


class VulnUpdateNotification(NotificationBase):
    data: Optional[VulnUpdateNotificationData] = None


class AnalysisArchiveRules(RootModel[List[AnalysisArchiveTransitionRule]]):
    root: List[AnalysisArchiveTransitionRule] = Field(
        ...,
        description='Rule set for automatic archiving of system objects and flushing of archived objects (permament delete).',
    )


class AnalysisUpdateNotification(NotificationBase):
    data: Optional[AnalysisUpdateNotificationData] = None


class PaginatedVulnerabilityList(PaginationProperties):
    vulnerabilities: Optional[List[StandaloneVulnerability]] = Field(
        None,
        description='The listing of matching vulnerabilities for the query subject to pagination',
    )


class PolicyBundleList(RootModel[List[PolicyBundleRecord]]):
    root: List[PolicyBundleRecord] = Field(
        ..., description='List of PolicyBundleRecord objects'
    )
